#include <ros/ros.h>
#include <vector>
#include <cmath>

#include <sensor_msgs/PointCloud2.h>
#include <std_msgs/Float64.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Pose2D.h>
#include <visualization_msgs/Marker.h>

#include <pcl_ros/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/passthrough.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/segmentation/extract_clusters.h>

#include <pcl/io/pcd_io.h>
#include <pcl/filters/conditional_removal.h>
#include <pcl/filters/extract_indices.h>

using namespace std;
typedef pcl::PointXYZI pointType;

class twoD_to_pcl{

private:
	ros::NodeHandle nh_;
	ros::Subscriber sub_2d_;
	ros::Publisher pub_points_, pub_center_;
	
	geometry_msgs::Point wayPoint_;	
	
	vector<pcl::PointCloud<pointType>> clustered_;
	vector<pcl::PointXYZ> center_;
	
	//local variable
	pcl::PointCloud<pointType>::Ptr msg;

	//parmeter
	float min_x_, max_x_,min_y_, max_y_;
	float cluster_tolerance_;
	int cluster_minsize_;
	int cluster_maxsize_;
	
public:
	//creator
	twoD_to_pcl() {
		// show log in terminal
		cout << "twoD_to_pcl Initialized" << endl;
		
		//pointcloud vector reset
		msg.reset(new pcl::PointCloud<pointType>());	
		
		// initialize Settings
		initSetup();	
	}
	
	// destructor
	~twoD_to_pcl(){
		// show log in terminal
		cout << "twoD_to_pcl Terminated" << endl;
	}
	
	void initSetup();	
	void scanCallback(const sensor_msgs::PointCloud2::ConstPtr &scan);
	void clustering();
	void twoD_to_pcl::visualize_center(pcl::PointCloud<pointType> car);
};

	void twoD_to_pcl::initSetup() {
		// initialize Flag
		ros::param::get("~min_x", min_x_);
		ros::param::get("~max_x", max_x_);
		ros::param::get("~min_y", min_y_);
		ros::param::get("~max_y", max_y_);

		ros::param::get("~cluster_tolerance", cluster_tolerance_);
		ros::param::get("~cluster_minsize", cluster_minsize_);
		ros::param::get("~cluster_maxsize", cluster_maxsize_);

		// set subscriber
		sub_2d_ = nh_.subscribe("/lidar2D", 10, &twoD_to_pcl::scanCallback, this);

		// set publisher
		pub_points_ = nh_.advertise<sensor_msgs::PointCloud2>("/passed_points", 10);
		pub_center_ = nh_.advertise<visualization_msgs::Marker>("/obstacle_center", 10);
        	//pub_marker_ = nh_.advertise<visualization_msgs::Marker>("wayPoint", 10);
	}

	void twoD_to_pcl::scanCallback(const sensor_msgs::PointCloud2::ConstPtr &scan) {
		pcl::fromROSMsg(*scan, *msg);
	}
	
	void twoD_to_pcl::clustering(){
		pcl::PointCloud<pointType>::Ptr center (new pcl::PointCloud<pointType>);

		pcl::PassThrough<pointType> pass;

		pass.setInputCloud(msg);
		pass.setFilterFieldName ("x");
		pass.setFilterLimits(min_x_, max_x_);
		pass.filter(*msg);

		pass.setInputCloud(msg);
		pass.setFilterFieldName("y");
		pass.setFilterLimits(min_y_, max_y_);
		pass.filter(*msg);



		sensor_msgs::PointCloud2 filteredOutput;
		pcl::toROSMsg(*msg, filteredOutput);
		filteredOutput.header.frame_id = "/velodyne";
		pub_points_.publish(filteredOutput);

		
		pcl::search::KdTree<pointType>::Ptr kdtree(new pcl::search::KdTree<pointType>);
		kdtree -> setInputCloud(msg);

		std::vector<pcl::PointIndices> clusterIndices;
		pcl::EuclideanClusterExtraction<pointType> ec;

		ec.setClusterTolerance(cluster_tolerance_);
		ec.setMinClusterSize(cluster_minsize_);
		ec.setMaxClusterSize(cluster_maxsize_);
		ec.setSearchMethod(kdtree);
		ec.setInputCloud(msg);
		ec.extract(clusterIndices);

		ROS_INFO("cluster number %i", clusterIndices.size());

		for (vector<pcl::PointIndices>::const_iterator it = clusterIndices.begin(); it != clusterIndices.end(); ++it) {
		    pointType Pt_center;
		    int count = 0;         
		    for (vector<int>::const_iterator pit = it->indices.begin(); pit != it->indices.end(); ++pit) {
			    Pt_center.x += msg->points[*pit].x;
			    Pt_center.y += msg->points[*pit].y;
			    count ++;
		    }            
		    Pt_center.x = Pt_center.x/count;
		    Pt_center.y = Pt_center.y/count;
		    Pt_center.z = 0;            
		    (*center).push_back(Pt_center);
		}
			    
	}

	void twoD_to_pcl::visualize_center(pcl::PointCloud<pointType> car) {
		visualization_msgs::Marker car_pt;
		geometry_msgs::Point point;

		car_pt.header.frame_id = "/velodyne";
		car_pt.header.stamp = ros::Time::now();
		car_pt.ns = "parked car";
		car_pt.action = visualization_msgs::Marker::ADD;
		car_pt.pose.orientation.w = 1.0;
		car_pt.id = 1;
		car_pt.type = visualization_msgs::Marker::POINTS;
		car_pt.scale.

		x = 0.3;
		car_pt.scale.y = 0.3;
		car_pt.color.a = 0.5;
		car_pt.color.r = 1.0f;

		for (int i = 0 ; i<car.size();i++){
		    point.x = car[i].x;
		    point.y = car[i].y;
		    point.z = 0;
		    car_pt.points.push_back(point);
		    pub_center_.publish(car_pt);
		}
	}

	


// ############################# Main Code #############################

int main(int argc, char **argv) {
	// set Node
	ros::init(argc, argv, "2d_to_pcl_node");

	// 2d data to pcl data
	twoD_to_pcl p;

	//ros roop 
	ros::Rate loop_rate(10);
	while(ros::ok()){
		ros::spinOnce();
		p.clustering();
		loop_rate.sleep();
	}
	
	return 0;
}



